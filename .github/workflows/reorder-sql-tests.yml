name: Reorder SQL tests

on:
  workflow_dispatch:
  push:
    branches:
      - feature/backoffice

jobs:
  run-sql-tests:
    name: Run reorder & view SQL tests
    runs-on: ubuntu-latest
    env:
      SUPABASE_TOKEN: ${{ secrets.SUPABASE_TOKEN }}
      SUPABASE_PROJECT_REF: ${{ secrets.SUPABASE_PROJECT_REF }}
      TEST_DB_URL: ${{ secrets.TEST_DB_URL }}
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install psql client
        run: sudo apt-get update && sudo apt-get install -y postgresql-client

      - name: Install Supabase CLI (optional)
        run: |
          echo "Installing Supabase CLI from GitHub releases (official binary)..."
          set -euo pipefail

          API_URL="https://api.github.com/repos/supabase/cli/releases/latest"
          echo "Querying latest release from $API_URL"

          ASSET_URL=$(curl -sSf "$API_URL" \
            | grep '"browser_download_url":' \
            | sed -E 's/.*"([^"]+)".*/\1/' \
            | grep -E 'linux' \
            | grep -E '\.(tar\.gz|tar\.xz|zip)$' \
            | head -n 1 || true)

          if [ -z "$ASSET_URL" ]; then
            echo "No suitable Linux asset found in latest release; falling back to npm install (best-effort)"
            npm install -g supabase@latest || true
            supabase --version || true
            exit 0
          fi

          echo "Found asset: $ASSET_URL"
          TMPFILE=/tmp/supabase_asset
          echo "Downloading to $TMPFILE"
          curl -L --retry 3 --retry-delay 2 "$ASSET_URL" -o "$TMPFILE"

          case "$ASSET_URL" in
            *.tar.gz)
              tar -xzf "$TMPFILE" -C /tmp
              ;;
            *.tar.xz)
              tar -xJf "$TMPFILE" -C /tmp
              ;;
            *.zip)
              unzip -q "$TMPFILE" -d /tmp
              ;;
            *)
              echo "Unknown archive format for $ASSET_URL" >&2
              exit 1
              ;;
          esac

          BINPATH=$(find /tmp -maxdepth 2 -type f -name supabase -print -quit || true)
          if [ -z "$BINPATH" ]; then
            echo "Could not locate 'supabase' binary inside the archive" >&2
            ls -la /tmp || true
            exit 1
          fi

          echo "Installing supabase binary from $BINPATH to /usr/local/bin"
          sudo mv "$BINPATH" /usr/local/bin/supabase
          sudo chmod +x /usr/local/bin/supabase
          supabase --version || true

      - name: Apply declarative schema to Supabase Cloud (optional)
        if: ${{ env.SUPABASE_TOKEN != '' && env.SUPABASE_PROJECT_REF != '' }}
        env:
          SUPABASE_ACCESS_TOKEN: ${{ env.SUPABASE_TOKEN }}
          SUPABASE_PROJECT_REF: ${{ env.SUPABASE_PROJECT_REF }}
        run: |
          echo "Linking to Supabase project $SUPABASE_PROJECT_REF and pushing schema"
          supabase link --project-ref "$SUPABASE_PROJECT_REF"
          # Push local migrations + declarative schema to the linked cloud project
          supabase db push --linked --yes || supabase db push --linked || true

      - name: Audit DB for broad grants (fail if exposed objects)
        env:
          TEST_DB_URL: ${{ secrets.TEST_DB_URL }}
          PGHOST: 127.0.0.1
          PGPORT: 5432
          PGUSER: postgres
          PGPASSWORD: postgres
        run: |
          echo "Running security audit: looking for objects granted to PUBLIC/anon/authenticated"
          # Choose DB URL: prefer secret TEST_DB_URL if provided, else use local service
          if [ -n "${TEST_DB_URL:-}" ]; then
            DBURL="$TEST_DB_URL"
          else
            DBURL="postgresql://$PGUSER:$PGPASSWORD@$PGHOST:$PGPORT/postgres?sslmode=disable"
          fi

          # Run audit SQL and check for any non-empty output (any row -> fail)
          set +e
          OUT=$(psql "$DBURL" -q -t -A -f supabase/scripts/audit_grants.sql | sed '/^$/d' | head -n 1 || true)
          set -e

          if [ -n "$OUT" ]; then
            echo "Security audit FAILED: found objects exposed to PUBLIC/anon/authenticated"
            # Show a little context for debugging
            psql "$DBURL" -q -t -A -f supabase/scripts/audit_grants.sql | sed -n '1,200p' || true
            exit 1
          fi
          echo "Security audit passed: no exposed objects detected."

      - name: Show test plan
        run: |
          echo "Test SQL: supabase/tests/20251025_test_reorder_and_views.sql"
          echo "If you have a Supabase or Postgres test DB, set the secret TEST_DB_URL to run against it."

      - name: Run tests against provided DB (recommended)
        if: ${{ env.TEST_DB_URL != '' }}
        env:
          TEST_DB_URL: ${{ env.TEST_DB_URL }}
        run: |
          echo "Using TEST_DB_URL secret"
          psql "$TEST_DB_URL" -f supabase/tests/20251025_test_reorder_and_views.sql

      - name: Fallback - run tests against local Postgres service
        if: ${{ env.TEST_DB_URL == '' }}
        env:
          PGHOST: 127.0.0.1
          PGPORT: 5432
          PGUSER: postgres
          PGPASSWORD: postgres
        run: |
          # Wait for postgres service to be ready
          echo "Waiting for postgres service..."
          for i in {1..30}; do
            pg_isready -h "$PGHOST" -p "$PGPORT" && break || sleep 1
          done
          echo "Running test SQL against local Postgres service"
          psql "postgresql://$PGUSER:$PGPASSWORD@$PGHOST:$PGPORT/postgres?sslmode=disable" -f supabase/tests/20251025_test_reorder_and_views.sql || true

      - name: Upload test artifacts (logs)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: reorder-test-sql
          path: |
            supabase/tests/20251025_test_reorder_and_views.sql
